% The following constants MUST be defined in file a before this one:
%   #const time_max=TM.  % Maximum time steps to simulate before failure.
%   #const int_min=IMN.  % Least integer allowed to exist.
%   #const int_max=IMX.  % Greatest integer allowed to exist.

% The following constants MAY be defined in a file before this one:
%   #const stack_max=SM. % Maximum number of entries in the call stack;
%                        % if not given, defaults to 0.

#include "utility.lp".
#const stack_max=@maybe_num(stack_max, 0).

% In specifying the program to run, the following facts may be given:
%   sub_line_instr((P,N),I). % In subroutine P, the instruction on line N>0 is I.
%   line_instr(N,I).         % Equivalent to sub_line_instr((main,N),I).
%   main_sub(P).             % Start execution in subroutine P, instead of 'main'.
%   in(R,V,C).               % In run R, the variable V starts with the value C.

% In addition, facts of the following form may be given:
%     array(A,L).
% These declare the existence of an array of integers named A, meaning that
% a new variable array(A,I) is introduced for each I in {0..L-1}. Variables
% not generated by this mechanism are called /scalar variables/.

% In addition, facts of the following form may be given:
%     local(P, V).
% This declares the variable V as /local/ in subroutine P, meaning that
% the value of V within an invocation of P is always unchanged by calling
% any further subroutine. This is implemented by saving the value of V on
% the call stack when needed.

% Instructions I may take the following forms:
%   set(L,E)    % Assign to location L the value of expression E (see below).
%   while(B,S)  % For as long as boolean B holds (see below),
%               % repeatedly execute the next S instructions.
%   if(B,S)     % Execute the next S instructions iff boolean B holds.
%   end_while   % Must occur exactly after the body of each while loop.
%   call(P)     % Transfer control to a subroutine, continuing when it ends.

% Locations L may take the following forms:
%   V               % The scalar variable V.
%   array(A,con(I)) % The variable array(A,I).
%   array(A,var(V)) % The variable array(A,I), where var(V) evaluates to I.

% Expressions E may take the following forms:
%   con(C)          % A constant numerical value between int_min and int_max.
%   var(V)          % The value of the scalar variable V.
%   array(A,con(I)) % Contents of array A at a constant index I.
%   array(A,var(V)) % Contents of array A at a variable index V.
%   add(E1,E2)      % Addition.
%   sub(E1,E2)      % Subtraction.
%   mul(E1,E2)      % Multiplication.
%   div(E1,E2)      % (Floored) integer division.
%   mod(E1,E2)      % (Signed) modular residue.

% Boolean guards B may take the following forms:
%   lt(E1,E2)   % Value of expression E1 is less than that of E2.
%   le(E1,E2)   % Value of expression E1 is less than or equal to that of E2.

% The answer set will contain some or all of the following facts:
%   run_var_out(R,V,C)    % In run R, the variable V ended with the value C.
%   run_does_not_halt(R)  % Run R failed to halt, due to timeout, overflow, etc.

%#hide.
%#show run_var_out/3.
%#show run_does_not_halt/1.
%#show run_fail/4.

%------------------------------------------------------------------------------- 
% Silence certain warnings due to undefined predicates.

line_instr(never,never)     :- in(never,never,never).
in(never,never,never)       :- sub_line_instr(never,never).
sub_line_instr(never,never) :- array(never,never).
array(never,never)          :- array(never,never,never).
array(never,never,never)    :- line_instr(never,never).

%------------------------------------------------------------------------------- 
% Effect line_instr/2 shorthand for sub_line_instr/2.

sub_line_instr((main,N),I) :- line_instr(N,I).

%------------------------------------------------------------------------------- 
% Domain predicates derived from constants, sub_line_instr/2, and array/2.

int(int_min..int_max).
line(L) :- sub_line_instr(L, _).

scalar_var(V) :- line_expr_occurs(_, var(V)).
scalar_var(V) :- sub_line_instr(_, set(V, _)), not array_expr(V).

array_expr(array(A,E)) :- sub_line_instr(_, set(array(A,E), _)).
array_expr(array(A,E)) :- line_expr_occurs(_, array(A,E)).

% Which arithmetic and boolean expressions occur in the program
% at given times and in given runs?
line_expr_occurs(L, E) :- sub_line_instr(L, set(_, E)).
line_expr_occurs(L, E) :- sub_line_instr(L, set(array(_, E), _)).
line_expr_occurs(L, E) :- line_expr_occurs(L, array(_, E)).
line_expr_occurs(L, E) :- line_binop_occurs(L, E, _).
line_expr_occurs(L, E) :- line_binop_occurs(L, _, E).

line_bool_occurs(L, B) :- sub_line_instr(L, if(B, _)).
line_bool_occurs(L, B) :- sub_line_instr(L, while(B, _)).

line_binop_occurs(L, A, B) :- line_expr_occurs(L, add(A,B)).
line_binop_occurs(L, A, B) :- line_expr_occurs(L, sub(A,B)).
line_binop_occurs(L, A, B) :- line_expr_occurs(L, mul(A,B)).
line_binop_occurs(L, A, B) :- line_expr_occurs(L, div(A,B)).
line_binop_occurs(L, A, B) :- line_expr_occurs(L, mod(A,B)).
line_binop_occurs(L, A, B) :- line_bool_occurs(L, lt(A,B)).
line_binop_occurs(L, A, B) :- line_bool_occurs(L, le(A,B)).

run_expr_occurs(R, T, E) :- run_line(R, T, L), line_expr_occurs(L, E).
run_bool_occurs(R, T, B) :- run_line(R, T, L), line_bool_occurs(L, B).

% Projection of if/while parameters.
line_instr_if_guard(L, G)     :- sub_line_instr(L, if(G, _)).
line_instr_if_length(L, B)    :- sub_line_instr(L, if(_, B)).
line_instr_while_guard(L, G)  :- sub_line_instr(L, while(G, _)).
line_instr_while_length(L, B) :- sub_line_instr(L, while(_, B)).

%-------------------------------------------------------------------------------
% Program interpreter.

#include "run_common.lp".

% Evaluate arithmetic expressions.
run_expr(R,T,con(C),C) :-
    run_expr_occurs(R,T,con(C)).

run_expr(R,T,E,C) :-
    E=var(V), run_expr_occurs(R,T,E), run_var(R,T,V,C).

run_expr(R,T,E,C) :-
    E=array(A,IE), run_expr_occurs(R,T,E),
    run_expr(R,T,IE,I), run_var(R,T,array(A,I),C).
run_expr(R,T,array(A,IE),unset) :-
    run_expr_occurs(R,T,array(A,IE)), run_expr(R,T,IE,unset).
run_expr(R,T,array(A,IE),unset) :-
    run_expr_occurs(R,T,array(A,IE)), run_expr(R,T,IE,I),
    not run_var(R,array(A,I)).

run_expr(R,T,E,C) :-
    E=add(E1,E2), run_expr_occurs(R,T,E),
    run_expr(R,T,E1,C1), run_expr(R,T,E2,C2),
    C1!=unset, C2!=unset, C = C1 + C2, int(C).

run_expr(R,T,E,C) :-
    E=sub(E1,E2), run_expr_occurs(R,T,E),
    run_expr(R,T,E1,C1), run_expr(R,T,E2,C2),
    C1!=unset, C2!=unset, C = C1 - C2, int(C).

run_expr(R,T,E,C) :-
    E=mul(E1,E2), run_expr_occurs(R,T,E),
    run_expr(R,T,E1,C1), run_expr(R,T,E2,C2),
    C1!=unset, C2!=unset, C = C1 * C2, int(C).

run_expr(R,T,E,C) :-
    E=div(E1,E2), run_expr_occurs(R,T,E),
    run_expr(R,T,E1,C1), run_expr(R,T,E2,C2),
    C1!=unset, C2!=unset, C2 != 0, C = (C1 #div C2), int(C).

run_expr(R,T,E,C) :-
    E=mod(E1,E2), run_expr_occurs(R,T,E),
    run_expr(R,T,E1,C1), run_expr(R,T,E2,C2),
    C1!=unset, C2!=unset, C2 != 0, C = (C1 #mod C2), int(C).

run_expr(R,T,add(E1,E2),unset) :- run_expr_occurs(R,T,add(E1,E2)), run_expr(R,T,E2,unset).
run_expr(R,T,add(E1,E2),unset) :- run_expr_occurs(R,T,add(E1,E2)), run_expr(R,T,E1,unset).
run_expr(R,T,add(E1,E2),unset) :- run_expr_occurs(R,T,add(E1,E2)), run_expr(R,T,E1,C1), run_expr(R,T,E2,C2), C1!=unset, C2!=unset, not int(C1+C2).

run_expr(R,T,sub(E1,E2),unset) :- run_expr_occurs(R,T,sub(E1,E2)), run_expr(R,T,E2,unset).
run_expr(R,T,sub(E1,E2),unset) :- run_expr_occurs(R,T,sub(E1,E2)), run_expr(R,T,E1,unset).
run_expr(R,T,sub(E1,E2),unset) :- run_expr_occurs(R,T,sub(E1,E2)), run_expr(R,T,E1,C1), run_expr(R,T,E2,C2), C1!=unset, C2!=unset, not int(C1-C2).

run_expr(R,T,mul(E1,E2),unset) :- run_expr_occurs(R,T,mul(E1,E2)), run_expr(R,T,E2,unset).
run_expr(R,T,mul(E1,E2),unset) :- run_expr_occurs(R,T,mul(E1,E2)), run_expr(R,T,E1,unset).
run_expr(R,T,mul(E1,E2),unset) :- run_expr_occurs(R,T,mul(E1,E2)), run_expr(R,T,E1,C1), run_expr(R,T,E2,C2), C1!=unset, C2!=unset, not int(C1*C2).

run_expr(R,T,div(E1,E2),unset) :- run_expr_occurs(R,T,div(E1,E2)), run_expr(R,T,E2,unset).
run_expr(R,T,div(E1,E2),unset) :- run_expr_occurs(R,T,div(E1,E2)), run_expr(R,T,E1,unset).
run_expr(R,T,div(E1,E2),unset) :- run_expr_occurs(R,T,div(E1,E2)), run_expr(R,T,E1,C1), run_expr(R,T,E2,C2), C1!=unset, C2!=unset, not int(C1-C2).
run_expr(R,T,div(E1,E2),unset) :- run_expr_occurs(R,T,div(E1,E2)), run_expr(R,T,E1,C1), run_expr(R,T,E2,0).

run_expr(R,T,mod(E1,E2),unset) :- run_expr_occurs(R,T,mod(E1,E2)), run_expr(R,T,E2,unset).
run_expr(R,T,mod(E1,E2),unset) :- run_expr_occurs(R,T,mod(E1,E2)), run_expr(R,T,E1,unset).
run_expr(R,T,mod(E1,E2),unset) :- run_expr_occurs(R,T,mod(E1,E2)), run_expr(R,T,E1,C1), run_expr(R,T,E2,C2), C1!=unset, C2!=unset, not int(C1-C2).
run_expr(R,T,mod(E1,E2),unset) :- run_expr_occurs(R,T,mod(E1,E2)), run_expr(R,T,E1,C1), run_expr(R,T,E2,0).


% Evaluate boolean expressions.
run_bool(R,T,B,true) :-
    B=lt(E1,E2), run_bool_occurs(R,T,B),
    run_expr(R,T,E1,C1),
    run_expr(R,T,E2,C2),
    C1!=unset, C2!=unset, C1 < C2.

run_bool(R,T,B,false) :-
    B=lt(E1,E2), run_bool_occurs(R,T,B),
    run_expr(R,T,E1,C1),
    run_expr(R,T,E2,C2),
    C1!=unset, C2!=unset, C1 >= C2.

run_bool(R,T,B,true) :-
    B=le(E1,E2), run_bool_occurs(R,T,B),
    run_expr(R,T,E1,C1),
    run_expr(R,T,E2,C2),
    C1!=unset, C2!=unset, C1 <= C2.

run_bool(R,T,B,false) :-
    B=le(E1,E2), run_bool_occurs(R,T,B),
    run_expr(R,T,E1,C1),
    run_expr(R,T,E2,C2),
    C1!=unset, C2!=unset, C1 > C2.
