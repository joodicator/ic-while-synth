% The following constants MUST be defined in file before this one:
% #const line_max=LM.   % The maximum number of lines in the program.
% #const time_max=TM.   % Maximum time steps to simulate before failure.
% #const int_min=IMN.   % Minimum integer allowed to exist.
% #const int_max=IMX.   % Maximum integer allowed to exist.

% The following constants MAY be defined in a file before this one:
%   #const stack_max=SM. % Maximum number of entries in the call stack;
%                        % if not given, defaults to 0.

% In specifying a program to be learned, the following facts MAY be given:
% preset_line_instr(N,I)
%   At line N in subroutine 'main', the instruction I is forced to occur.
% preset_sub_line_instr((P,N),I)
%   In subroutine P, the instruction at line N is I.

% con(N).         % N is a constant that may occur as a literal in the code.
% var(V).         % V is a variable that may be used in the program.
% array(A,L).     % A is an array of length at most L that may be used.
%                 % Implies existance of variables array(A,I) : I=0..L-1.

% write_var(V).   % The variable V may be written to in the program.
% write_array(A). % The contents of the array A may be written to.
% disallow(F).    % Feature F may not be used (see feature/1).

% array(R,A,L).   % In run R, the array A is of length at most L.
% in(R,V,C).      % In run R, the variable V starts with the value C.
% out(R,V,C).     % In run R, the variable V must finish with the value C.

#hide.
#show sub_line_instr/2.

%-------------------------------------------------------------------------------
% Silence certain warnings for undefined predicates:
in(never,never,never)           :- out(never,never,never).
out(never,never,never)          :- preset_line_instr(never,never).
preset_line_instr(never,never)  :- con(never).
con(never)                      :- write_array(never).
write_array(never)              :- array(never,never,never,never).
array(never,never,never,never)  :- array(never,never,never).
array(never,never,never)        :- con(never,never).
con(never,never)                :- var(never,never).
var(never,never)                :- in(never,never,never).

%-------------------------------------------------------------------------------
% Features allowed in the program.
subfeature(all,        if; while; arithmetic; comparison).
subfeature(arithmetic, add; sub; mul; div; mod).

feature(F) :- subfeature(F,_).
feature(G) :- subfeature(_,G).

disallow(G) :- subfeature(F,G), disallow(F).
allow(F)    :- feature(F), not disallow(F).

disallow(G,T) :- subfeature(F,G), disallow(F,T).
allow(F,T)    :- feature(F), type(T), not disallow(F,T).

% Inheritance of features from global context.
disallow(F,T) :- disallow(F), type(T).
allow(F,T)    :- allow(F), type(T).

int(int_min..int_max).

%-------------------------------------------------------------------------------
% Variables generated by array/2.
array_var(array(A,I)) :- array(A,L), I=0..L-1, int(I).
scalar_var(V)         :- var(V), not array_var(V).
var(V)                :- array_var(V).
write_var(array(A,I)) :- array_var(array(A,I)), write_array(A).

%-------------------------------------------------------------------------------
% Types generated by type/2.
% 
% A /leaf/ is an atomic object that may be assigned a type by the user:
% a constant, a variable, or the element or index type of an array. If a leaf
% is not assigned any type, it is assumed to have all types. If there are no
% types defined, the type 'any' is introduced, and assigned to all leaves.
%
% Two typed objects are /compatible/ if they have at least one type in common.
% The two leaves in a binary expression must be compatible with each other, and
% the expression's type is the intersection of their types. The subscript in an
% array index must be compatible with the index types of that array. The target
% of an assignment statement must be compatible with the expression.

con(C)         :- con(C, _).
con_type(C, T) :- con(C, T).

var(V)         :- var(V, _).
var_type(V, T) :- var(V, T).

array(A)         :- array(A,_).
array(A,L)       :- array(A,L,_,_).
elem_type(A,ET)  :- array(A,_,ET,_).
index_type(A,IT) :- array(A,_,_,IT).

leaf(con(C))   :- con(C).
leaf(var(V))   :- scalar_var(V).
leaf(elem(A))  :- array(A).
leaf(index(A)) :- array(A).

maybe_leaf_type(con(C),T)   :- con_type(C,T).
maybe_leaf_type(var(V),T)   :- var_type(V,T).
maybe_leaf_type(elem(A),T)  :- elem_type(A,T).
maybe_leaf_type(index(A),T) :- index_type(A,T).

type(any).
type(T) :- maybe_leaf_type(_, T).

leaf_type(L,T) :- maybe_leaf_type(L,T).
leaf_type(L,T) :- leaf(L), type(T), not any_leaf_type(L).
any_leaf_type(L) :- maybe_leaf_type(L,T), T != any.

compat(L1,L2) :- leaf_type(L1;L2, T).

expr_type(L,T)          :- expr(L), leaf_type(L,T).
expr_type(array(A,E),T) :- expr(array(A,E)), leaf_type(elem(A),T).
expr_type(add(E1,E2),T) :- expr(add(E1,E2)), leaf_type(E1,T), leaf_type(E2,T).
expr_type(sub(E1,E2),T) :- expr(sub(E1,E2)), leaf_type(E1,T), leaf_type(E2,T).
expr_type(mul(E1,E2),T) :- expr(mul(E1,E2)), leaf_type(E1,T), leaf_type(E2,T).
expr_type(div(E1,E2),T) :- expr(div(E1,E2)), leaf_type(E1,T), leaf_type(E2,T).
expr_type(mod(E1,E2),T) :- expr(mod(E1,E2)), leaf_type(E1,T), leaf_type(E2,T).

%-------------------------------------------------------------------------------
% Exactly one instruction per line.
1{ sub_line_instr((main,N), I) : valid_line_instr(N, I) }1 :-
    line((main,N)), not line_preset((main,N)).
line((main, 1..line_max)).
line_preset(L) :- preset_sub_line_instr(L,_).
line(L)        :- line_preset(L).

% Every test example must halt:
:- run_does_not_halt(R).

% Every test example must match any given input/output example:
:- run_var_out(R,V,Actual), out(R,V,Expected), Actual != Expected.

%-------------------------------------------------------------------------------
% Instructions.
valid_line_instr(N, set(V, E)) :-
    line((main,N)), write_var(V), E!=var(V),
    leaf_type(var(V),T), expr_type(E,T).

valid_line_instr(N, set(array(A,con(I)), E)) :-
    line((main,N)), write_var(array(A,I)), E!=array(A,I),
    leaf_type(index(A),IT), leaf_type(con(I),IT),
    leaf_type(elem(A),ET), expr_type(E,ET).

valid_line_instr(N, set(array(A,var(V)), E)) :-
    line((main,N)), write_array(A),
    leaf_type(index(A),IT), leaf_type(var(V),IT),
    leaf_type(elem(A),ET), expr_type(E,ET).   

valid_line_instr(N, if(B, 1..M)) :-
    line((main,N)), allow(if), bool(B), M=line_max-N.

valid_line_instr(N, while(B, 1..M)) :-
    line((main,N)), allow(while), bool(B), M=line_max-N-1.

valid_line_instr(N, end_while) :-
    line((main,N)), N >= 3, allow(while).

valid_line_instr(N, call(P)) :-
    line((main,N)), subroutine(P), P != main.

preset_sub_line_instr((main,N),I) :- preset_line_instr(N,I).
sub_line_instr(L,I)   :- preset_sub_line_instr(L,I).
subroutine(P)         :- preset_sub_line_instr((P,_),_).

% Which arithmetic and boolean expressions occur in the program
% at given times and in given runs?
line_expr_occurs(L, E) :- preset_sub_line_instr(L, set(_, E)).
line_expr_occurs(L, E) :- preset_sub_line_instr(L, set(array(_, E), _)).
line_expr_occurs(L, E) :- line_expr_occurs(L, array(_, E)).
line_expr_occurs(L, E) :- line_binop_occurs(L, E, _).
line_expr_occurs(L, E) :- line_binop_occurs(L, _, E).

line_bool_occurs(L, B) :- preset_sub_line_instr(L, if(B, _)).
line_bool_occurs(L, B) :- preset_sub_line_instr(L, while(B, _)).

line_binop_occurs(L, A, B) :- line_expr_occurs(L, add(A,B)).
line_binop_occurs(L, A, B) :- line_expr_occurs(L, sub(A,B)).
line_binop_occurs(L, A, B) :- line_expr_occurs(L, mul(A,B)).
line_binop_occurs(L, A, B) :- line_expr_occurs(L, div(A,B)).
line_binop_occurs(L, A, B) :- line_expr_occurs(L, mod(A,B)).
line_binop_occurs(L, A, B) :- line_bool_occurs(L, lt(A,B)).
line_binop_occurs(L, A, B) :- line_bool_occurs(L, le(A,B)).

% Require end_while statements to occur at exactly the correct positions.
:- sub_line_instr(L,end_while), not end_while_block(L).
:- end_while_block(L), not sub_line_instr(L,end_while).
end_while_block((P,N)) :- line_instr_while_length((P,NH),B), N=NH+B+1.

% Forbid if/while blocks that end outside of a block they start within.
:- line_instr_if_length((P,N),M),
   block((P,PL),PM), PL<N, N<=PL+PM, N+M>PL+PM.
:- line_instr_while_length((P,N),M),
   block((P,PL),PM), PL<N, N<=PL+PM, N+M+1>PL+PM.

% block(L, M) if a code block starts after line L, and ends after line L+M.
block(L, M) :- sub_line_instr(L,    if(_, M)).
block(L, M) :- sub_line_instr(L, while(_, M)).

% Projection of if/while parameters.
line_instr_if_guard(L, G)     :- sub_line_instr(L, if(G, _)).
line_instr_if_length(L, B)    :- sub_line_instr(L, if(_, B)).
line_instr_while_guard(L, G)  :- sub_line_instr(L, while(G, _)).
line_instr_while_length(L, B) :- sub_line_instr(L, while(_, B)).

%-------------------------------------------------------------------------------
% Arithmetic expressions.

expr(E) :- line_expr_occurs(_, E).

expr(con(C))          :- con(C).
expr(var(V))          :- scalar_var(V).
expr(array(A,con(C))) :- con(C), array(A,L), C=0..L-1, leaf_type(index(A);con(C),IT).
expr(array(A,var(V))) :- scalar_var(V), array(A,_),    leaf_type(index(A);var(V),IT).

% add: commutative; disallow x+0; allow x+x iff not 2*x, x+(-|c|) iff not x-|c|.
expr(add(var(X), con(C))) :- leaf_type(var(X);con(C),T), allow(add,T), C > 0.
expr(add(var(X), con(C))) :- leaf_type(var(X);con(C),T), allow(add,T), C < 0,
                             not allow(sub,T):leaf_type(var(x);con(C),T):allow(add,T).
expr(add(var(X), con(C))) :- leaf_type(var(X);con(C),T), allow(add,T), C < 0,
                             not leaf_type(con(-C),T):leaf_type(var(X);con(C),T):allow(add,T).
expr(add(var(X), var(Y))) :- leaf_type(var(X);var(Y),T), allow(add,T), X < Y.
expr(add(var(X), var(X))) :- allow(add,T), leaf_type(var(X),T),
                             not allow(mul,T):leaf_type(var(X),T).
expr(add(var(X), var(X))) :- allow(add,T), leaf_type(var(X),T),
                             not leaf_type(con(2),T):allow(add,T).

% sub: disallow x-0, x-x; allow x-(-|c|) iff not x+|c|, 0-x iff not -1*x.
expr(sub(var(X), var(Y))) :- leaf_type(var(X);var(Y),T), allow(sub,T), X != Y.
expr(sub(var(X), con(C))) :- leaf_type(var(X);con(C),T), allow(sub,T), C > 0.
expr(sub(var(X), con(C))) :- leaf_type(var(X);con(C),T), allow(sub,T), C < 0,
                             not allow(add,T):leaf_type(var(X);con(C),T):allow(sub,T).
expr(sub(var(X), con(C))) :- leaf_type(var(X);con(C),T), allow(sub,T), C < 0,
                             not leaf_type(con(-C),T):leaf_type(var(X);con(C),T):allow(sub,T).
expr(sub(con(C), var(X))) :- leaf_type(con(C);var(X),T), allow(sub,T), C != 0.
expr(sub(con(0), var(X))) :- leaf_type(con(0);var(X),T), allow(sub,T),
                             not allow(mul,T):leaf_type(con(0);var(X),T):allow(sub,T).
expr(sub(con(0), var(X))) :- leaf_type(con(0);var(X),T), allow(sub,T),
                             not leaf_type(con(-1),T):leaf_type(con(0);var(X),T):allow(sub,T).

% mul: commutative; disallow 0*x, 1*x.
expr(mul(var(X), var(Y))) :- leaf_type(var(X);var(Y),T), allow(mul,T), X <= Y.
expr(mul(con(C), var(X))) :- leaf_type(con(C);var(X),T), allow(mul,T), C != 0, C != 1.

% div: disallow x/x; disallow c/x and x/c for all c < 2.
expr(div(var(X), var(Y))) :- leaf_type(var(X);var(Y),T), allow(div,T), X != Y.
expr(div(con(C), var(X))) :- leaf_type(con(C);var(X),T), allow(div,T), C > 1.
expr(div(var(X), con(C))) :- leaf_type(var(X);con(C),T), allow(div), C > 1.

% mod: disallow x%x, disallow c%x for all c < 2, x%c for all c < 1.
expr(mod(var(X), var(Y))) :- leaf_type(var(X);var(Y),T), allow(mod,T), X != Y.
expr(mod(con(C), var(X))) :- leaf_type(con(C);var(X),T), allow(mod,T), C > 0.
expr(mod(var(X), con(C))) :- leaf_type(var(X);con(C),T), allow(mod,T), C > 1.

%-------------------------------------------------------------------------------
% Boolean expressions. Note that:
%   x <  y  <=>  lt(x,y)
%   x >  y  <=>  lt(y,x)
%   x <= y  <=>  le(x,y)
%   x >= y  <=>  le(y,x)
%   x == y  <=>  le(x,y) AND le(y,x)
%   x != y  <=>  lt(x,y) OR  lt(y,x)

bool(B) :- line_bool_occurs(_, B).

% x < int_min  <->  false
% x > int_max  <->  false
bool(lt(var(X), var(Y))) :- leaf_type(var(X);var(Y),T), allow(comparison,T),
                            X != Y.
bool(lt(var(X), con(C))) :- leaf_type(var(X);con(C),T), allow(comparison,T),
                            C > int_min.
bool(lt(con(C), var(X))) :- leaf_type(var(X);con(C),T), allow(comparison,T),
                            C < int_max.

% x <= c  <->  x < c+1;  x <= int_max  <-> true
% c <= x  <->  c-1 < x;  x >= int_min  <-> true
bool(le(var(X), var(Y))) :- leaf_type(var(X);var(Y),T), allow(comparison,T),
                            X != Y.
bool(le(var(X), con(C))) :- leaf_type(var(X);con(C),T), allow(comparison,T),
                            C < int_max, not con(C+1).
bool(le(con(C), var(X))) :- leaf_type(var(X);con(C),T), allow(comparison,T),
                            C > int_min, not con(C-1).

%-------------------------------------------------------------------------------
% Program interpreter.

#include "run_common.lp".

% Evaluate arithmetic expressions.
run_leaf_expr(R,T,E,C) :-
    E=con(C), int(C), expr(E), run(R,T).
run_leaf_expr(R,T,E,C) :-
    E=var(V), var(V), expr(E), run_var(R,T,V,C).

run_expr(R,T,E,C) :-
    run_leaf_expr(R,T,E,C).

run_expr(R,T,E,C) :-
    E=array(A,IE), expr(E), expr(IE),
    run_leaf_expr(R,T,IE,I), run_var(R,T,array(A,I),C).

run_expr(R,T,E,C) :-
    E=add(E1,E2), expr(E),
    run_leaf_expr(R,T,E1,C1), run_leaf_expr(R,T,E2,C2),
    C = C1 + C2, int(C).

run_expr(R,T,E,C) :-
    E=sub(E1,E2), expr(E),
    run_leaf_expr(R,T,E1,C1), run_leaf_expr(R,T,E2,C2),
    C = C1 - C2, int(C).

run_expr(R,T,E,C) :-
    E=mul(E1,E2), expr(E),
    run_leaf_expr(R,T,E1,C1), run_leaf_expr(R,T,E2,C2),
    C = C1 * C2, int(C).

run_expr(R,T,E,C) :-
    E=div(E1,E2), expr(E),
    run_leaf_expr(R,T,E1,C1), run_leaf_expr(R,T,E2,C2),
    C2 != 0, C = (C1 #div C2), int(C).

run_expr(R,T,E,C) :-
    E=mod(E1,E2), expr(E),
    run_leaf_expr(R,T,E1,C1), run_leaf_expr(R,T,E2,C2),
    C2 != 0, C = (C1 #mod C2), int(C).

% Evaluate boolean expressions.
run_bool(R,T,B) :-
    B=lt(E1,E2), bool(B),
    run_leaf_expr(R,T,E1,C1),
    run_leaf_expr(R,T,E2,C2),
    C1 < C2.

run_bool(R,T,B) :-
    B=le(E1,E2), bool(B),
    run_leaf_expr(R,T,E1,C1),
    run_leaf_expr(R,T,E2,C2),
    C1 <= C2.

% Identify booleans which evaluate to a legal result.
run_bool_not_fail(R,T,B) :-
    B=lt(E1,E2), bool(B),
    run_expr(R,T,E1,_), run_expr(R,T,E2,_).
run_bool_not_fail(R,T,B) :-
    B=le(E1,E2), bool(B),
    run_expr(R,T,E1,_), run_expr(R,T,E2,_).
